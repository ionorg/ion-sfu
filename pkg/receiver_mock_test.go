// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package sfu

import (
	"github.com/pion/rtcp"
	"github.com/pion/webrtc/v3"
	"sync"
)

// Ensure, that ReceiverMock does implement Receiver.
// If this is not the case, regenerate this file with moq.
var _ Receiver = &ReceiverMock{}

// ReceiverMock is a mock implementation of Receiver.
//
//     func TestSomethingThatUsesReceiver(t *testing.T) {
//
//         // make and configure a mocked Receiver
//         mockedReceiver := &ReceiverMock{
//             AddSenderFunc: func(sender Sender)  {
// 	               panic("mock out the AddSender method")
//             },
//             CloseFunc: func()  {
// 	               panic("mock out the Close method")
//             },
//             DeleteSenderFunc: func(pid string)  {
// 	               panic("mock out the DeleteSender method")
//             },
//             OnCloseHandlerFunc: func(fn func())  {
// 	               panic("mock out the OnCloseHandler method")
//             },
//             ReadRTCPFunc: func() chan rtcp.Packet {
// 	               panic("mock out the ReadRTCP method")
//             },
//             SpatialLayerFunc: func() uint8 {
// 	               panic("mock out the SpatialLayer method")
//             },
//             TrackFunc: func() *webrtc.Track {
// 	               panic("mock out the Track method")
//             },
//             WriteBufferedPacketFunc: func(sn uint16, track *webrtc.Track, snOffset uint16, tsOffset uint32, ssrc uint32) error {
// 	               panic("mock out the WriteBufferedPacket method")
//             },
//             WriteRTCPFunc: func(in1 rtcp.Packet) error {
// 	               panic("mock out the WriteRTCP method")
//             },
//         }
//
//         // use mockedReceiver in code that requires Receiver
//         // and then make assertions.
//
//     }
type ReceiverMock struct {
	// AddSenderFunc mocks the AddSender method.
	AddSenderFunc func(sender Sender)

	// CloseFunc mocks the Close method.
	CloseFunc func()

	// DeleteSenderFunc mocks the DeleteSender method.
	DeleteSenderFunc func(pid string)

	// OnCloseHandlerFunc mocks the OnCloseHandler method.
	OnCloseHandlerFunc func(fn func())

	// ReadRTCPFunc mocks the ReadRTCP method.
	ReadRTCPFunc func() chan rtcp.Packet

	// SpatialLayerFunc mocks the SpatialLayer method.
	SpatialLayerFunc func() uint8

	// TrackFunc mocks the Track method.
	TrackFunc func() *webrtc.Track

	// WriteBufferedPacketFunc mocks the WriteBufferedPacket method.
	WriteBufferedPacketFunc func(sn uint16, track *webrtc.Track, snOffset uint16, tsOffset uint32, ssrc uint32) error

	// WriteRTCPFunc mocks the WriteRTCP method.
	WriteRTCPFunc func(in1 rtcp.Packet) error

	// calls tracks calls to the methods.
	calls struct {
		// AddSender holds details about calls to the AddSender method.
		AddSender []struct {
			// Sender is the sender argument value.
			Sender Sender
		}
		// Close holds details about calls to the Close method.
		Close []struct {
		}
		// DeleteSender holds details about calls to the DeleteSender method.
		DeleteSender []struct {
			// Pid is the pid argument value.
			Pid string
		}
		// OnCloseHandler holds details about calls to the OnCloseHandler method.
		OnCloseHandler []struct {
			// Fn is the fn argument value.
			Fn func()
		}
		// ReadRTCP holds details about calls to the ReadRTCP method.
		ReadRTCP []struct {
		}
		// SpatialLayer holds details about calls to the SpatialLayer method.
		SpatialLayer []struct {
		}
		// Track holds details about calls to the Track method.
		Track []struct {
		}
		// WriteBufferedPacket holds details about calls to the WriteBufferedPacket method.
		WriteBufferedPacket []struct {
			// Sn is the sn argument value.
			Sn uint16
			// Track is the track argument value.
			Track *webrtc.Track
			// SnOffset is the snOffset argument value.
			SnOffset uint16
			// TsOffset is the tsOffset argument value.
			TsOffset uint32
			// Ssrc is the ssrc argument value.
			Ssrc uint32
		}
		// WriteRTCP holds details about calls to the WriteRTCP method.
		WriteRTCP []struct {
			// In1 is the in1 argument value.
			In1 rtcp.Packet
		}
	}
	lockAddSender           sync.RWMutex
	lockClose               sync.RWMutex
	lockDeleteSender        sync.RWMutex
	lockOnCloseHandler      sync.RWMutex
	lockReadRTCP            sync.RWMutex
	lockSpatialLayer        sync.RWMutex
	lockTrack               sync.RWMutex
	lockWriteBufferedPacket sync.RWMutex
	lockWriteRTCP           sync.RWMutex
}

// AddSender calls AddSenderFunc.
func (mock *ReceiverMock) AddSender(sender Sender) {
	if mock.AddSenderFunc == nil {
		panic("ReceiverMock.AddSenderFunc: method is nil but Receiver.AddSender was just called")
	}
	callInfo := struct {
		Sender Sender
	}{
		Sender: sender,
	}
	mock.lockAddSender.Lock()
	mock.calls.AddSender = append(mock.calls.AddSender, callInfo)
	mock.lockAddSender.Unlock()
	mock.AddSenderFunc(sender)
}

// AddSenderCalls gets all the calls that were made to AddSender.
// Check the length with:
//     len(mockedReceiver.AddSenderCalls())
func (mock *ReceiverMock) AddSenderCalls() []struct {
	Sender Sender
} {
	var calls []struct {
		Sender Sender
	}
	mock.lockAddSender.RLock()
	calls = mock.calls.AddSender
	mock.lockAddSender.RUnlock()
	return calls
}

// Close calls CloseFunc.
func (mock *ReceiverMock) Close() {
	if mock.CloseFunc == nil {
		panic("ReceiverMock.CloseFunc: method is nil but Receiver.Close was just called")
	}
	callInfo := struct {
	}{}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//     len(mockedReceiver.CloseCalls())
func (mock *ReceiverMock) CloseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// DeleteSender calls DeleteSenderFunc.
func (mock *ReceiverMock) DeleteSender(pid string) {
	if mock.DeleteSenderFunc == nil {
		panic("ReceiverMock.DeleteSenderFunc: method is nil but Receiver.DeleteSender was just called")
	}
	callInfo := struct {
		Pid string
	}{
		Pid: pid,
	}
	mock.lockDeleteSender.Lock()
	mock.calls.DeleteSender = append(mock.calls.DeleteSender, callInfo)
	mock.lockDeleteSender.Unlock()
	mock.DeleteSenderFunc(pid)
}

// DeleteSenderCalls gets all the calls that were made to DeleteSender.
// Check the length with:
//     len(mockedReceiver.DeleteSenderCalls())
func (mock *ReceiverMock) DeleteSenderCalls() []struct {
	Pid string
} {
	var calls []struct {
		Pid string
	}
	mock.lockDeleteSender.RLock()
	calls = mock.calls.DeleteSender
	mock.lockDeleteSender.RUnlock()
	return calls
}

// OnCloseHandler calls OnCloseHandlerFunc.
func (mock *ReceiverMock) OnCloseHandler(fn func()) {
	if mock.OnCloseHandlerFunc == nil {
		panic("ReceiverMock.OnCloseHandlerFunc: method is nil but Receiver.OnCloseHandler was just called")
	}
	callInfo := struct {
		Fn func()
	}{
		Fn: fn,
	}
	mock.lockOnCloseHandler.Lock()
	mock.calls.OnCloseHandler = append(mock.calls.OnCloseHandler, callInfo)
	mock.lockOnCloseHandler.Unlock()
	mock.OnCloseHandlerFunc(fn)
}

// OnCloseHandlerCalls gets all the calls that were made to OnCloseHandler.
// Check the length with:
//     len(mockedReceiver.OnCloseHandlerCalls())
func (mock *ReceiverMock) OnCloseHandlerCalls() []struct {
	Fn func()
} {
	var calls []struct {
		Fn func()
	}
	mock.lockOnCloseHandler.RLock()
	calls = mock.calls.OnCloseHandler
	mock.lockOnCloseHandler.RUnlock()
	return calls
}

// ReadRTCP calls ReadRTCPFunc.
func (mock *ReceiverMock) ReadRTCP() chan rtcp.Packet {
	if mock.ReadRTCPFunc == nil {
		panic("ReceiverMock.ReadRTCPFunc: method is nil but Receiver.ReadRTCP was just called")
	}
	callInfo := struct {
	}{}
	mock.lockReadRTCP.Lock()
	mock.calls.ReadRTCP = append(mock.calls.ReadRTCP, callInfo)
	mock.lockReadRTCP.Unlock()
	return mock.ReadRTCPFunc()
}

// ReadRTCPCalls gets all the calls that were made to ReadRTCP.
// Check the length with:
//     len(mockedReceiver.ReadRTCPCalls())
func (mock *ReceiverMock) ReadRTCPCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockReadRTCP.RLock()
	calls = mock.calls.ReadRTCP
	mock.lockReadRTCP.RUnlock()
	return calls
}

// SpatialLayer calls SpatialLayerFunc.
func (mock *ReceiverMock) SpatialLayer() uint8 {
	if mock.SpatialLayerFunc == nil {
		panic("ReceiverMock.SpatialLayerFunc: method is nil but Receiver.SpatialLayer was just called")
	}
	callInfo := struct {
	}{}
	mock.lockSpatialLayer.Lock()
	mock.calls.SpatialLayer = append(mock.calls.SpatialLayer, callInfo)
	mock.lockSpatialLayer.Unlock()
	return mock.SpatialLayerFunc()
}

// SpatialLayerCalls gets all the calls that were made to SpatialLayer.
// Check the length with:
//     len(mockedReceiver.SpatialLayerCalls())
func (mock *ReceiverMock) SpatialLayerCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockSpatialLayer.RLock()
	calls = mock.calls.SpatialLayer
	mock.lockSpatialLayer.RUnlock()
	return calls
}

// Track calls TrackFunc.
func (mock *ReceiverMock) Track() *webrtc.Track {
	if mock.TrackFunc == nil {
		panic("ReceiverMock.TrackFunc: method is nil but Receiver.Track was just called")
	}
	callInfo := struct {
	}{}
	mock.lockTrack.Lock()
	mock.calls.Track = append(mock.calls.Track, callInfo)
	mock.lockTrack.Unlock()
	return mock.TrackFunc()
}

// TrackCalls gets all the calls that were made to Track.
// Check the length with:
//     len(mockedReceiver.TrackCalls())
func (mock *ReceiverMock) TrackCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockTrack.RLock()
	calls = mock.calls.Track
	mock.lockTrack.RUnlock()
	return calls
}

// WriteBufferedPacket calls WriteBufferedPacketFunc.
func (mock *ReceiverMock) WriteBufferedPacket(sn uint16, track *webrtc.Track, snOffset uint16, tsOffset uint32, ssrc uint32) error {
	if mock.WriteBufferedPacketFunc == nil {
		panic("ReceiverMock.WriteBufferedPacketFunc: method is nil but Receiver.WriteBufferedPacket was just called")
	}
	callInfo := struct {
		Sn       uint16
		Track    *webrtc.Track
		SnOffset uint16
		TsOffset uint32
		Ssrc     uint32
	}{
		Sn:       sn,
		Track:    track,
		SnOffset: snOffset,
		TsOffset: tsOffset,
		Ssrc:     ssrc,
	}
	mock.lockWriteBufferedPacket.Lock()
	mock.calls.WriteBufferedPacket = append(mock.calls.WriteBufferedPacket, callInfo)
	mock.lockWriteBufferedPacket.Unlock()
	return mock.WriteBufferedPacketFunc(sn, track, snOffset, tsOffset, ssrc)
}

// WriteBufferedPacketCalls gets all the calls that were made to WriteBufferedPacket.
// Check the length with:
//     len(mockedReceiver.WriteBufferedPacketCalls())
func (mock *ReceiverMock) WriteBufferedPacketCalls() []struct {
	Sn       uint16
	Track    *webrtc.Track
	SnOffset uint16
	TsOffset uint32
	Ssrc     uint32
} {
	var calls []struct {
		Sn       uint16
		Track    *webrtc.Track
		SnOffset uint16
		TsOffset uint32
		Ssrc     uint32
	}
	mock.lockWriteBufferedPacket.RLock()
	calls = mock.calls.WriteBufferedPacket
	mock.lockWriteBufferedPacket.RUnlock()
	return calls
}

// WriteRTCP calls WriteRTCPFunc.
func (mock *ReceiverMock) WriteRTCP(in1 rtcp.Packet) error {
	if mock.WriteRTCPFunc == nil {
		panic("ReceiverMock.WriteRTCPFunc: method is nil but Receiver.WriteRTCP was just called")
	}
	callInfo := struct {
		In1 rtcp.Packet
	}{
		In1: in1,
	}
	mock.lockWriteRTCP.Lock()
	mock.calls.WriteRTCP = append(mock.calls.WriteRTCP, callInfo)
	mock.lockWriteRTCP.Unlock()
	return mock.WriteRTCPFunc(in1)
}

// WriteRTCPCalls gets all the calls that were made to WriteRTCP.
// Check the length with:
//     len(mockedReceiver.WriteRTCPCalls())
func (mock *ReceiverMock) WriteRTCPCalls() []struct {
	In1 rtcp.Packet
} {
	var calls []struct {
		In1 rtcp.Packet
	}
	mock.lockWriteRTCP.RLock()
	calls = mock.calls.WriteRTCP
	mock.lockWriteRTCP.RUnlock()
	return calls
}
